"""
Lib for automation some of the exploit process

Credits to icker2x for pattern create and offset 

Classes:
    Pattern

Functions:
    test

Misc variables:
    test
"""

from ctypes import sizeof
import sys
import struct  
import pykd
import keystone as ks
import capstone as cs
import pefile

class Pattern():
    """
    A class to access pattern_offset and pattern_create

    Methods
    -------
    print_help():
        Print usage for standalone scripts

    pattern_create():
        Return pattern as STRING length is determined in constructor, convert to bytes before sending in buffer ie. bytes(pattern,"ascii")

    pattern_offset(value=0xffffff):
        Return pattern offset as int
    """
    def __init__(self,buffer_length):
        """
        Constructs all the neccesary attributes for the pattern object

        Parameters:
        -----------
        buffer_length : int
            length of buffer for pattern create and offset
        """
        self.buffer_length = buffer_length

    def print_help():
        print(f"Usage: {sys.argv[0]} (create | offset) <value> <buflen>")
        sys.exit(0)

    def pattern_create(self):
        length = self.buffer_length
        pattern = ""
        parts = ["A","a","0"]
        try:
            if not isinstance(length,(int)):
                length = int(length)
        except Exception as e:
            print(f"::: Error creating pattern -> {e} :::")
            self.print_help()
        while len(pattern) != length:
            pattern += parts[len(pattern) % 3]
            if len(pattern) % 3 == 0:
                parts[2] = chr(ord(parts[2]) + 1)
                if parts[2] > '9':
                    parts[2] = '0'
                    parts[1] = chr(ord(parts[1])+1)
                    if parts[1] > 'z':
                        parts[1] = 'a'
                        parts[0] = chr(ord(parts[0]) +1)
                        if parts[0] > 'Z':
                            parts[0] = 'A'
        return pattern
    
    def pattern_offset(self,offset_value):
        length = self.buffer_length
        value = offset_value
        try:
            if not isinstance(value,int) and value.startswith("0x"):
                value_stripped = value.strip("0x")
                value = struct.pack("<I",int(value_stripped,16))
            elif not isinstance(value,int):
                value = struct.pack("<I",int(value,16))
            else:
                value = struct.pack("<I",int(value))
        except Exception as e:
            print(f"::: Failed to pack offset -> {e} :::")
            return False
        try:
            str_value = value.decode("ascii")
            pattern = self.pattern_create()
        except Exception as e:
            print(f"::: Failed to decode offset to ascii -> {e} :::")
            return False
        try:
            return pattern.index(str_value)
        except Exception as e:
            return "Offset Not Found"


class Instructions():
    bad_chars_array = (
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
    b"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
    b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
    b"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
    b"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
    b"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
    b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
    b"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
    b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
    b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
    b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
    b"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
    b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
    b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
    b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
    b"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    )
    def convert_shellcode(self,assembly):
        eng = ks.Ks(ks.KS_ARCH_X86,ks.KS_MODE_32)
        shellcode = "\n".join(assembly)
        encoding,count = eng.asm(shellcode)
        final = ""
        for enc in encoding:
            final += "\\x{0:02x}".format(enc)
        return final

class Rop():
    def __init__(self,path):
        self.path_to_pe = path
        self.csEngine = cs.Cs(cs.CS_ARCH_X86,cs.CS_MODE_32)
        self.pe = pefile.PE(self.path_to_pe,fast_load=True)
        self.image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.entry_point = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.dll_char = self.pe.OPTIONAL_HEADER.DllCharacteristics
        self.size_of_text_section = self.pe.OPTIONAL_HEADER.SizeOfCode

    def print_informtation(self):
        base_address_of_code_rva = self.pe.OPTIONAL_HEADER.BaseOfCode
        text_section_start = self.image_base + base_address_of_code_rva
        text_section_end = self.image_base + base_address_of_code_rva + self.size_of_text_section
        print("::: Information :::")
        print("Entry Point ->",hex(self.entry_point + self.image_base))
        print("Image Base  ->",hex(self.image_base))
        print("Image End   ->",hex(self.pe.OPTIONAL_HEADER.SizeOfImage+self.image_base))
        print("Size .text  ->",hex(self.size_of_text_section))
        print(".text start ->",hex(text_section_start))
        print(".text end   ->",hex(text_section_end))
        print("::: Sections :::")
        for section in self.pe.sections:
            print(section.Name.decode("ascii"),hex(section.VirtualAddress),section.SizeOfRawData)
        print("::: Protections :::")
        self.check_protections()

    def check_protections(self):
        if self.dll_char & 0x0040:
            print("::: ASLR Enabled ::: ")
        if self.dll_char & 0x0100:
            print("::: DEP Enabled :::")
        if self.dll_char & 0x4000:
            print("::: CFG Supported :::")
        if self.dll_char & 0x0400:
            print("::: SEH Not Used :::")
            
    def find_jmp_esp(self):
        print("::: Finding jmp esp :::")
        print("::: Searching .text only :::")
        data = self.pe.sections[0].get_data()[::]
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
            if mnemonic == "jmp" and op_str == "esp":
                absolute_addr = self.image_base + address
                print("::: Found jmp esp :::")
                print("::: {} ::: {} ::: {} {}".format(hex(absolute_addr),hex(address),mnemonic,op_str))
                return absolute_addr

    def find_pop_pop_ret(self):
        print("::: Finding Pop Pop Ret :::")
        print("::: Searching .text only :::")
        data = self.pe.sections[0].get_data()[::]
        possible_addresses = []
        pop_pop_ret = []
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
            if mnemonic == "pop" or mnemonic == "ret":
                absolute_addr = self.image_base + address
                address_and_opcodes = {
                    "absolute_addr":absolute_addr,
                    "address":address,
                    "mnemonic":mnemonic,
                    "op_str":op_str
                }
                possible_addresses.append(address_and_opcodes)
        for x in range(len(possible_addresses)-1):
            if possible_addresses[x]["address"] + 1 == possible_addresses[x+1]["address"] and possible_addresses[x]["address"] + 2 == possible_addresses[x+2]["address"] and possible_addresses[x+2]["mnemonic"] == "ret" and possible_addresses[x+2]["op_str"] == "":
                    print("::: {}  {}  {} {}".format(hex(possible_addresses[x]["absolute_addr"]),hex(possible_addresses[x]["address"]),possible_addresses[x]["mnemonic"],possible_addresses[x]["op_str"]),end=" ::: ")
                    print("::: {}  {}  {} {}".format(hex(possible_addresses[x+1]["absolute_addr"]),hex(possible_addresses[x+1]["address"]),possible_addresses[x+1]["mnemonic"],possible_addresses[x+1]["op_str"]),end=" ::: ")
                    print("::: {}  {}  {} {}".format(hex(possible_addresses[x+2]["absolute_addr"]),hex(possible_addresses[x+2]["address"]),possible_addresses[x+2]["mnemonic"],possible_addresses[x+2]["op_str"]))
                    pop_pop_ret.append(possible_addresses[x])
                    x+=2
        return pop_pop_ret

    def find_all(self,specific_mnemonic=None):
        data = self.pe.sections[0].get_data()[::]
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
                absolute_addr = self.image_base + address
                print("::: {} ::: {} ::: {} {}".format(hex(absolute_addr),hex(address),mnemonic,op_str))

    def find_gadgets(self,specific_mnemonic=None):
        data = self.pe.sections[0].get_data()[::]
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
                absolute_addr = self.image_base + address
                print("::: {} ::: {} ::: {} {}".format(hex(absolute_addr),hex(address),mnemonic,op_str))

if __name__ == "__main__":
    Rop("..\Chapter3\VulnApp1.exe").find_pop_pop_ret()

